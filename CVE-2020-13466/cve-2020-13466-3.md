# A QUICK(ish) LOOK AT STM32 HARDWARE SECURITY (PART 4)

***20/1/22***

***Continues from [part 3](./cve-2020-13466-2.md). I will use this CVE to crack GNUK usb token.***

## 1. Quick reminder

In the [first post](../CVE-2020-8004/cve-2020-8004.md) of this series, I setup a potential target - The GNUK usb token to test CVE-2020-8004 with. However, the result was a bit disappointing since the recovered firmware is only abot 89% of the original. Datas were corrupted, including the keys which was the primary target.

With CVE-2020-13466 fully covered, 100% of the firmware can be dumped without corruption, open the path for extracting the keys. In this post I will cover how the usb token stores the keys in flash and how to decrypt them - yes they are encrypted.

And needless to say using STM32F1 for GNUK is no longer recommended.

## 2. Key location

After dumping the flash with CVE-2020-13466, we are left with a dump binary. To find the key we must look into GNUK\'s source \[[2]\].

Start from *openpgp-do.c*, which contains handler for openpgp commands

```c
static int
gpg_do_write_prvkey (enum kind_of_key kk, const uint8_t *key_data,
             int prvkey_len, const uint8_t *keystring_admin,
             const uint8_t *pubkey)
```

This function is responsible for writing keys to flash. In the arguments *key_data* and *prvkey_len* is private key and key length, *pubkey* is public key data, *keystring_admin* is token admin password and is not important, *kk* is one of 3 type shown below.

```c
enum kind_of_key {
  GPG_KEY_FOR_SIGNING = 0,
  GPG_KEY_FOR_DECRYPTION = 1,
  GPG_KEY_FOR_AUTHENTICATION = 2,
};
```

Key page address will be determined using constant *FLASH_ADDR_KEY_STORAGE_START* (its value is assigned at link time) and *kk* - kind of key. Align by page size of STM32F1 == 1024 bytes.

```c
FLASH_ADDR_KEY_STORAGE_START + (flash_page_size * kk);
```

So from *FLASH_ADDR_KEY_STORAGE_START*, each kind of key will start from page offset 0, 1, and 2 respectively.

For final address, the code will search from its start page and increment by key size until it hit address with 0xffffffff. I did not look further if this introduces key overwrite or not since this is not my goal. But for normal usage its safe to say *final address == page offset address* for each kind of keys.

For blue pill build with configuration in part 1 FLASH_ADDR_KEY_STORAGE_START should be at 0x0801ac00.

## 3. Key decryption

```c
static void
encrypt (const uint8_t *key, const uint8_t *iv, uint8_t *data, int len)
{
  aes_context aes;
  uint8_t iv0[INITIAL_VECTOR_SIZE];
  size_t iv_offset;

  aes_setkey_enc (&aes, key, 128);
  memcpy (iv0, iv, INITIAL_VECTOR_SIZE);
  iv_offset = 0;
  aes_crypt_cfb128 (&aes, AES_ENCRYPT, len, &iv_offset, iv0, data, data);
}
```

```c
struct key_data_internal {
  uint32_t data[(MAX_PRVKEY_LEN+DATA_ENCRYPTION_KEY_SIZE) / sizeof (uint32_t)];
  /*
   * Secret key data.
   * RSA: p and q, ECDSA/ECDH: d, EdDSA: a+seed
   */
  /* Checksum */
};
```

```c
int aes_crypt_cfb128( aes_context *ctx,
                       int mode,
                       size_t length,
                       size_t *iv_off,
                       unsigned char iv[16],
                       const unsigned char *input,
                       unsigned char *output )
```

```c
int
gpg_do_load_prvkey (enum kind_of_key kk, int who, const uint8_t *keystring)
```

### 3.1.

## 4. Conclusion
ctf idea - keys fit in 1536 bits

## References

1. [GNUK Documentation](http://www.fsij.org/doc-gnuk/index.html)cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf)
2. [GNUK\'s source](https://salsa.debian.org/gnuk-team/gnuk/gnuk)
3. []()

[1]: http://www.fsij.org/doc-gnuk/index.html
[2]: https://salsa.debian.org/gnuk-team/gnuk/gnuk
[3]: 